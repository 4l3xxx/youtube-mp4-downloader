const express = require('express');const path = require('path');const fs = require('fs');const os = require('os');const { spawn } = require('child_process');// Configconst PORT = process.env.PORT || 3000;const DOWNLOAD_TIMEOUT_MS = Number(process.env.DOWNLOAD_TIMEOUT_MS || 10 * 60 * 1000); // 10 minutesconst app = express();// Basic health endpointapp.get('/healthz', (_req, res) => res.status(200).send('ok'));// Serve static files (front-end)app.use(express.static(path.join(__dirname, '..', 'public'), {  extensions: ['html']}));// Utility: create a unique temp directory for each requestfunction makeTempDir() {  const base = fs.mkdtempSync(path.join(os.tmpdir(), 'ytmp4-'));  return base;}// Utility: basic URL validationfunction isLikelyUrl(str) {  try {    const u = new URL(str);    return !!u.protocol && !!u.hostname;  } catch (_) {    return false;  }}// Sanitize filename for headers and cross-OS safetyfunction sanitizeFileName(name) {  // Remove control chars and Windows-forbidden characters  return name    .replace(/[\u0000-\u001F\u007F]+/g, '')    .replace(/[<>:"/\\|?*]+/g, '')    .trim();}// GET /download?url=...// Triggers a server-side yt-dlp + ffmpeg download to MP4, then streams as an attachment.app.get('/download', async (req, res) => {  const videoUrl = (req.query.url || '').toString().trim();  if (!videoUrl || !isLikelyUrl(videoUrl)) {    return res.status(400).send('Invalid or missing URL.');  }  // Defensive: do not allow local network traversal  try {    const parsed = new URL(videoUrl);    const host = parsed.hostname.toLowerCase();    if (/(localhost|127\.0\.0\.1|0\.0\.0\.0|::1)$/.test(host)) {      return res.status(400).send('Local URLs are not allowed.');    }  } catch (_) {    return res.status(400).send('Invalid URL.');  }  // Create temp working directory  const workDir = makeTempDir();  // Use video title for output name to avoid generic video.mp4  const outputTemplate = path.join(workDir, '%(title)s.%(ext)s');  // yt-dlp command  // Strategy:  // - Select best video+audio, prefer MP4; fallback gracefully  // - Merge output to mp4  // - Output to a deterministic name (video.mp4)  const ytdlpArgs = [    '-f', 'bv*+ba/b[ext=mp4]/b',    '--merge-output-format', 'mp4',    '--audio-quality', '0',    '--audio-format', 'aac',    '--recode-video', 'mp4',    '-o', outputTemplate,    '--no-playlist',    videoUrl  ];  // Optionally restrict filename characters to be safe  // ytdlpArgs.push('--restrict-filenames');  const child = spawn('yt-dlp', ytdlpArgs, {    cwd: workDir,    stdio: ['ignore', 'pipe', 'pipe']  });  let stderrBuf = '';  child.stderr.on('data', (d) => {    // Accumulate a small tail of stderr for potential error reporting    if (stderrBuf.length < 4000) stderrBuf += d.toString();  });  const timeout = setTimeout(() => {    child.kill('SIGKILL');  }, DOWNLOAD_TIMEOUT_MS);  child.on('error', (err) => {    clearTimeout(timeout);    try { fs.rmSync(workDir, { recursive: true, force: true }); } catch (_) {}    if (err && err.code === 'ENOENT') {      return res.status(500).send('Server is missing yt-dlp. Please install yt-dlp and ffmpeg.');    }    return res.status(500).send('Failed to start download process.');  });  child.on('close', (code) => {    clearTimeout(timeout);    if (code !== 0) {      try { fs.rmSync(workDir, { recursive: true, force: true }); } catch (_) {}      return res.status(500).send('Download failed.\n' + stderrBuf);    }    // Locate the produced file (video.mp4)    let produced;    try {      const entries = fs.readdirSync(workDir);      produced = entries.find((f) => f.toLowerCase().endsWith('.mp4'));    } catch (e) {      try { fs.rmSync(workDir, { recursive: true, force: true }); } catch (_) {}      return res.status(500).send('Failed to read output.');    }    if (!produced) {      try { fs.rmSync(workDir, { recursive: true, force: true }); } catch (_) {}      return res.status(500).send('No MP4 produced.');    }    const filePath = path.join(workDir, produced);    // Set download headers    res.setHeader('Content-Type', 'video/mp4');    // Try to produce a friendly filename    // If yt-dlp normalized the name, keep it; otherwise fallback    const downloadName = produced;    // Stream the file as an attachment    res.setHeader('Content-Disposition', `attachment; filename="${downloadName.replace(/"/g, '')}"`);    // Override header with sanitized filename to avoid ERR_INVALID_CHAR    {      const baseName = path.parse(produced).name;      const safeTitle = sanitizeFileName(baseName) || 'video';      res.setHeader('Content-Disposition', `attachment; filename="${safeTitle}.mp4"`);    }    const readStream = fs.createReadStream(filePath);    readStream.on('error', () => {      try { fs.rmSync(workDir, { recursive: true, force: true }); } catch (_) {}      if (!res.headersSent) res.status(500).end('Failed to read file.'); else res.end();    });    res.on('close', () => {      // Client disconnected or finished; cleanup temp dir      try { fs.rmSync(workDir, { recursive: true, force: true }); } catch (_) {}    });    readStream.pipe(res);  });});app.listen(PORT, () => {  // eslint-disable-next-line no-console  console.log(`Server listening on http://localhost:${PORT}`);});